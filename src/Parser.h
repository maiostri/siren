/**
 * @file
 *
 * This file implements SQL extended parser.
 *
 * @version 1.0
 *
 * @author Maria Camila Nardini Barioni (mcamila@icmc.usp.br)
 * @todo Documentation review and tests.
 */

#ifndef __PARSER_H
#define __PARSER_H

#define MAX_SCOPE 10

#include <string>
#include <vector>
#include <iostream>

#include "DataDictionaryAccess.h"
#include "utils/sirenUtils.h"
#include "sirenresult/SirenResult.h"

class Lex;
class Token;
class DataDictionaryAccess;
class MetricTreeManager;

using namespace std;

/**
 * This class implements a parser!
 *
 * @author Maria Camila Nardini Barioni (mcamila@icmc.usp.br)
 */
class Parser {
public:
	string StrTime;
	string TotalTime;

	string TimeInMilliseconds(time_t t) {
		long ms = t * 1000;
		stringstream out;
		out << ms;
		return out.str();
	}

	/**
	 * Parser constructor!!!
	 * @param input Siren SQL Statement to be parsed
	 * @param connection The database connection (BDE or dbExpress database component)
	 * @param treemanager Optional. The application might instantiate and control the metric tree manager.
	 */

	Parser(Connections::eConnections connectionsEnum, const string& input, const string& username,
			const string& password, MetricTreeManager *treemanager);

	/**
	 * Parser destructor!!!
	 * @todo Clean tokenlist
	 */
	~Parser();

	/**
	 * Use the Parse method to parse the input string.
	 */
	SirenResult * Parse();

	/**
	 * Returns if the statement is a select statement.
	 */
	bool IsSelectStatement() {
		return IsSelect;
	}

	/**
	 * Returns if the statement is an insert statement.
	 */
	bool IsInsertStatement() {
		return IsInsert;
	}

	/**
	 * ReturnCommands() returns the SQL statements generated by this system
	 */
	vector<string> *
	ReturnCommands() {
		return CommandList;
	}

	/**
	 * ReturnTokenList() returns the token list
	 */
	vector<string> *ReturnTokenList();

	/**
	 * Checks client folder
	 */
	bool RightClientFolder();

	/**
	 * Gets the client folder
	 */
	string ClientFolder();

	/**
	 *Gets the checkbox value (Optimizer).
	 */
	void SetCkOptimization(bool optimizer) {
		ckoptimization = optimizer;
	}

	bool GetCkOptimization() {
		return ckoptimization;
	}

	/**
	 * <b>Rule definition:</b><br>
	 * <metric_definition> ::= CREATE METRIC <metric_name> [USING LP0 |LP1 |LP2] FOR {PARTICULATE '(' particulate_param_ref_list ')' | STILLIMAGE '(' extractor_reference_list ')' | AUDIO '(' extractor_reference_list ')'}
	 */
	void metric_definition();

private:
	//========================================================
	// parser properties
	//========================================================

	/**
	 * Pointer to the lex analiser
	 */
	Lex *lex;

	/**
	 * Pointer to the data dictionary handler
	 */
	DataDictionaryAccess *datadictionary;

	/**
	 * Lookahead is the token that is being analised
	 */
	Token *Lookahead;

	/**
	 * TokenList is a pointer to the first token of the list of tokens
	 */
	Token **TokenList;

	/**
	 * TokenListTail is a pointer to the last token of the list of tokens
	 */
	Token **TokenListTail;

	/**
	 * Defines the active token list
	 */
	int ActiveTokenList;

	/**
	 * Number of scopes
	 */
	int TokenListCount;

	/**
	 * Error messages
	 */
	vector<string> *error;

	/**
	 * Determines if sql statement is a select. It is true if the first token is "select"
	 */
	bool IsSelect;

	/**
	 * Determines if sql statement is a select. It is true if the first token is "select"
	 */
	bool IsInsert;

	bool ckoptimization;

	//========================================================
	// parser methods!
	//========================================================

	/**
	 * Matchs the expected token with the token found
	 */
	void Match(string Identifier, int TokenType);

	/**
	 * Adds a token to the TokenList
	 */
	void AddToken(Token *token);

	//========================================================
	// rules properties
	//========================================================

	//--------------------------------------------------------
	// create metric rules properties
	//--------------------------------------------------------

	/**
	 * Stores the current extractor code
	 */
	int ExtractorCode;

	/**
	 * Stores the current metric code
	 */
	int MetricCode;

	//--------------------------------------------------------
	// create table rules properties
	//--------------------------------------------------------

	/**
	 * Stores the list of the IPV$ create tables
	 */
	vector<string> *CommandList;

	/**
	 * Stores the current list of image attributes
	 */
	vector<string> *CIAList;

	/**
	 * Stores the current particulate attribute
	 */
	vector<string> *CPAList;

	/**
	 * Stores the current audio attribute
	 */
	vector<string> *CAAList;

	/**
	 * Stores the list of complex attributes.
	 * It is used to avoid the association of the same metric more than one time for each image attribute.
	 * It is used to avoid the insertion of the same parameter more than one time in each IPV$ table.
	 */
	vector<string> *ComplexAttributeList;

	/**
	 * Stores the list of metrics associated with a complex attribute.
	 * It is used - in conjunction with the ComplexAttributeList - to avoid the association of the same metric more than one time for each image attribute.
	 * It is used - in conjunction with the ComplexAttributeList - to avoid the insertion of the same parameter more than one time in each IPV$ table.
	 */
	vector<string> *MetricReferenceList;

	/**
	 * Stores the list of metrics for each image attribute. It is needed for processing the metric table constraint.
	 */
	vector<string> *MetricList;

	/**
	 * Stores the list of Image Attributes that already has a default metric
	 * It is used to avoid the duplicity of default metrics for each image attribute
	 */
	vector<string> *DefaultMetricList;

	/**
	 * Stores the list of particle column names. It is used for handling the particulate data type.
	 */
	vector<string> *ParticleColName;

	/**
	 * Stores the list of particle column types. It is used for handling the particulate data type.
	 */
	vector<string> *ParticleColType;

	/**
	 * Stores the list of particulate parameters. It is used for handling the particulate data type.
	 */
	vector<string> *ParticulateParam;

	/**
	 * Stores the current column data type (stillimage or particulate)
	 */
	string CurrentColDataType;

	//--------------------------------------------------------
	// create index rules properties
	//--------------------------------------------------------

	/**
	 * Stores the current list of metrics
	 */
	string CurrentMetric;

	//--------------------------------------------------------
	// insert statement rules properties
	//--------------------------------------------------------

	/**
	 * Stores the image attribute list
	 */
	vector<string> *ImgAttribList;

	/**
	 * Stores the audio attribute list
	 */
	vector<string> *AudAttribList;

	/**
	 * Stores the insert column list
	 */
	vector<string> *InsertColList;

	/**
	 * Stores the insert value list
	 */
	vector<string> *InsertValueList;

	/**
	 * Stores a list of the image attribute position
	 */
	vector<string> *ImgAttribPosList;

	/**
	 * Stores a list of the audio attribute position
	 */
	vector<string> *AudAttribPosList;

	/**
	 * Stores the current image/audio attribute position (used for attributes that require feature extraction)
	 */
	int AttribPosition;

	/**
	 * Stores a list of parameters that are used in the insert commands used to alter IPV
	 */
	vector<string> *ImgInsertAuxList;

	/**
	 * Stores a list of parameters that are used in the insert commands used to alter APV
	 */
	vector<string> *AudInsertAuxList;

	//========================================================
	// rules methods
	//========================================================

	/**
	 * <b>Rule definition:</b><br>
	 * <sql_statement> ::= <sql_definition_statement> | <sql_manipulation_statement>
	 */
	SirenResult * sql_statement();

	/**
	 * <b>Rule definition:</b><br>
	 * <sql_definition_statement> ::= <table_definition> | ... | <metric_definition>
	 */
	void sql_definition_statement();

	/**
	 * <b>Rule definition:</b><br>
	 * <sql_manipulation_statement> ::= <query_specification> | ...
	 * @todo Insert the new select statement in the CommandList
	 */
	SirenResult * sql_manipulation_statement();

	//--------------------------------------------------------
	// create table rules methods
	//--------------------------------------------------------

	/**
	 * <b>Rule definition:</b><br>
	 * <table_definition> ::= CREATE TABLE <table_name> '(' <table_element_list> ')'
	 */
	void table_definition();

	/**
	 * <b>Rule definition:</b><br>
	 * <table_name> ::= <identifier>
	 */
	void table_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <table_element_list> ::= <table_element> | <table_element> ',' <table_element_list>
	 */
	void table_element_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <table_element> ::= <column_definition> | <table_constraint>
	 */
	void table_element();

	/**
	 * <b>Rule definition:</b><br>
	 * <column_definition> ::= <column_name> <data_type> [column_constraint_list]
	 */
	void column_definition();

	/**
	 * <b>Rule definition:</b><br>
	 * <column_name> ::= <identifier>
	 */
	void column_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <data_type> ::= See the Database data type documentation!
	 */
	void data_type();

	/**
	 * <b>Rule definition:</b><br>
	 * <column_constraint_list> ::= <column_constraint> | <column_constraint> <column_constraint_list>
	 */
	void column_constraint_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <column_constraint> ::= </td>
	 *     <td> [<constraint_name>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> NOT NULL </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | NULL </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | UNIQUE </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | PRIMARY KEY </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | REFERENCES <table_name> ['(' <column_name> ')'] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | METRIC [REFERENCES '(' <parameter_assoc_list> ')'] USING '(' <metric_name_list> ')' </td>
	 *   </tr>
	 * </table>
	 */
	void column_constraint();

	/**
	 * <b>Rule definition:</b><br>
	 * <constraint_name> ::= CONSTRAINT <identifier>
	 */
	void constraint_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <column_name_list> ::= <column_name> | <column_name> ',' <column_name_list>
	 */
	void column_name_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_assoc_list> ::= <parameter_assoc> | <parameter_assoc> ',' <parameter_assoc_list>
	 */
	void parameter_assoc_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_assoc> ::= <particle_column_ref> AS <parameter_name>
	 */
	void parameter_assoc();

	/**
	 * <b>Rule definition:</b><br>
	 * <metric_name_list> ::= <metric_name> [DEFAULT]| <metric_name> [DEFAULT]',' <metric_name_list><br>
	 * <b>Note:</b><br>
	 * If none of the metrics specified for an attribute is defined as "default", the system doesn't choose one. The user must specify one metric as default.
	 */
	void metric_name_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <metric_name> ::= <identifier>
	 */
	void metric_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <table_constraint> ::= </td>
	 *     <td> [<constraint_name>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> {PRIMARY KEY | UNIQUE} '(' <column_name_list> ')' </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | FOREIGN KEY '(' <column_name_list> ')' REFERENCES <table_name> ['(' <column_name_list> ')'] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | METRIC {'(' <stillimage_column_name_list> ')' | '(' <audio_column_name_list> ')' | '(' <particulate_column_name_list> ')' REFERENCES '(' <parameter_assoc_list> ')'} USING '(' <metric_name_list> ')'</td>
	 *   </tr>
	 * </table>
	 * <b>Note:</b><br>
	 * If none of the metrics specified for an attribute is defined as "default", the system doesn't choose one. The user must specify one metric as default.
	 */
	void table_constraint();

	/**
	 * <b>Rule definition:</b><br>
	 * <stillimage_column_name_list> ::= <stillimage_column_name> | <stillimage_column_name> ',' <stillimage_column_name_list>
	 */
	void stillimage_column_name_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <particulate_column_name_list> ::= <particulate_column_name> | <particulate_column_name> ',' <particulate_column_name_list>
	 */
	void particulate_column_name_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <audio_column_name_list> ::= <audio_column_name> | <audio_column_name> ',' <audio_column_name_list>
	 */
	void audio_column_name_list();

	//--------------------------------------------------------
	// create metric rules methods
	//--------------------------------------------------------

	/**
	 * <b>Rule definition:</b><br>
	 * <extractor_reference_list> ::= <extractor_reference> | <extractor_reference> ',' <extractor_reference_list>
	 */
	void extractor_reference_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <extractor_reference> ::= <extractor_name> '(' <parameter_reference_list> ')'
	 */
	void extractor_reference();

	/**
	 * <b>Rule definition:</b><br>
	 * <extractor_name> ::= <identifier>
	 */
	void extractor_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_reference_list> ::= <parameter_reference> | <parameter_reference> ',' <parameter_reference_list>
	 */
	void parameter_reference_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_reference> ::= <parameter_name> AS <parameter_alias> [<weight_value>]
	 */
	void parameter_reference();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_name> ::= <identifier>
	 */
	void parameter_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <particulate_param_ref_list> ::= <particulate_param_ref> | <particulate_param_ref> ',' <particulate_param_ref_list>
	 */
	void particulate_param_ref_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <particulate_param_ref> ::= <particulate_parameter_name> <parameter_type> [<weight_value>]
	 */
	void particulate_param_ref();

	//--------------------------------------------------------
	// create index rules methods
	//--------------------------------------------------------

	/**
	 * <b>Rule definition:</b><br>
	 * <index_definition> ::= CREATE INDEX <index_name> ON <table_name> '(' <complex_column_reference> ')' [REFERENCES '(' <param_assoc_ref_list> ')'] USING <metric_name_reference>
	 */
	void index_definition();

	/**
	 * <b>Rule definition:</b><br>
	 * <index_name> ::= <identifier>
	 */
	void index_name();

	/**
	 * <b>Rule definition:</b><br>
	 * <complex_column_reference> ::= <stillimage_column_name> | <particulate_column_name>
	 */
	void complex_column_reference();

	/**
	 * <b>Rule definition:</b><br>
	 * <param_assoc_ref_list> ::= <param_assoc_ref> | <param_assoc_ref> ',' <param_assoc_ref_list>
	 */
	void param_assoc_ref_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <param_assoc_ref> ::= <particle_column_ref> AS <parameter_name>
	 */
	void param_assoc_ref();

	/**
	 * <b>Rule definition:</b><br>
	 * <metric_name_reference> ::= <metric_name>
	 */
	void metric_name_reference();

	//--------------------------------------------------------
	// drop index rules methods
	//--------------------------------------------------------

	/**
	 * <b>Rule definition:</b><br>
	 * <drop_index_statement> ::= DROP INDEX <complex_index_name>
	 */
	void drop_index_statement();

	/**
	 * <b>Rule definition:</b><br>
	 * <complex_index_name> ::= <complex_attribute_identifier>
	 */
	void complex_index_name();

	//--------------------------------------------------------
	// select rules methods
	//--------------------------------------------------------

	/**
	 * <b>Rule definition:</b><br>
	 * <query_specification> ::= SELECT [DISTINCT | ALL] <select_list> <table_expression>
	 */
	void query_specification();

	/**
	 * <b>Rule definition:</b><br>
	 * <select_list> ::= '*' | <column_reference_list>
	 */
	void select_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <column_reference_list> ::= <column_reference> [ <as_clause> ] | <column_reference> [ <as_clause> ] ',' <column_reference_list>
	 */
	void column_reference_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <column_reference> ::= </td>
	 *     <td> <column_name> ['.'<extractor_name>'.'<extractor_parameter>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <table_name>'.'<column_name>['.'<extractor_name>'.'<extractor_parameter>] </td>
	 *   </tr>
	 * </table>
	 */
	void column_reference();

	/**
	 * <b>Rule definition:</b><br>
	 * <as_clause> ::= AS <identifier>
	 */
	void as_clause();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <table_expression> ::= </td>
	 *     <td> <from_clause> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <where_clause> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <group_by_clause> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <having_clause> </td>
	 *   </tr>
	 * </table>
	 * @todo <group_by_clause> and <having_clause>
	 */
	void table_expression();

	/**
	 * <b>Rule definition:</b><br>
	 * <from_clause> ::= FROM <table_reference_list>
	 */
	void from_clause();

	/**
	 * <b>Rule definition:</b><br>
	 * <table_reference_list> ::= <table_name> | <table_name> ',' <table_name_list>
	 */
	void table_reference_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <where_clause> ::= WHERE <search_condition>
	 */
	void where_clause();

	/**
	 * <b>Rule definition:</b><br>
	 * <groupby_clause> ::= GROUP BY <column_reference_list>
	 */
	void groupby_clause();

	/**
	 * <b>Rule definition:</b><br>
	 * <having_clause> ::= HAVING <search_condition>
	 */
	void having_clause();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <search_condition> ::= </td>
	 *     <td> NOT <search_condition> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <search_condition> AND <search_condition> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <search_condition> OR <search_condition> </td>
	 *   </tr>
	 * </table>
	 */
	void search_condition();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <predicate> ::= </td>
	 *     <td> <comparison_predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <between_predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <like_predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <test_for_null> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <in_predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <all_or_any_predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <existence_test> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <near_predicate> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> | <far_predicate> </td>
	 *   </tr>
	 * </table>
	 * <b>Notes:</b>
	 * <table border="0">
	 *   <tr>
	 *     <td> 1) </td>
	 *     <td> the operators <comparison_predicate>, <between_predicate>, <like_predicate>,
	 *     <test_for_null>, <in_predicate>, <all_or_any_predicate> and <existence_test> only
	 *     can be used with numeric and string attributes </td>
	 *   </tr>
	 *   <tr>
	 *     <td> 2) </td>
	 *     <td> the operators <near_predicate> and <far_predicate> only can be used with
	 *     complex attributes (stillimage or particulate) </td>
	 *   </tr>
	 * </table>
	 * @todo <between_predicate>, <like_predicate>, <test_for_null>, <in_predicate>, <all_or_any_predicate>, <existence_test>
	 */
	void predicate();

	/**
	 * <b>Rule definition:</b><br>
	 * <value_expression> ::= <string> | <integer> | <floating_point>
	 * @todo expression analysis
	 */
	void value_expression();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <near_predicate> ::= </td>
	 *     <td> <img_column_reference> NEAR [<similarity_grouping>] <image_definition> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> [BY <metric_name>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> [RANGE <val_range>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> [STOP AFTER <k_nearest> [WITH <tie_list>]] </td>
	 *   </tr>
	 * </table>
	 * @todo WITH <tie_list>
	 */
	void near_predicate();

	/**
	 * <b>Rule definition:</b><br>
	 * <query_obj_definition> ::= <complex_attribute_reference> | <subquery> | <particulate_reference> | <image_location> | <audio_location>
	 */
	void query_obj_definition();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_val_assoc_list> ::= <parameter_val_assoc> | <parameter_val_assoc> ',' <parameter_val_assoc_list>
	 */
	void parameter_val_assoc_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <parameter_val_assoc> ::= <particle_column_val_ref> as <parameter_name>
	 * <b>Notes:</b>
	 * <table border="0">
	 *   <tr>
	 *     <td> 1) </td>
	 *     <td> Only integer and floating point values are allowed to <particle_colum_val_ref>
	 *   </tr>
	 * </table>
	 */
	void parameter_val_assoc();

	/**
	 * <b>Rule definition:</b><br>
	 * <val_range> ::= TK_FLOATING_POINT | TK_INTEGER
	 */
	void val_range();

	/**
	 * <b>Rule definition:</b><br>
	 * <k_nearest> ::= TK_INTEGER
	 */
	void k_nearest();

	/**
	 * <b>Rule definition:</b><br>
	 * <tie_list> ::= TIE LIST
	 */
	void tie_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <table border="0">
	 *   <tr>
	 *     <td> <far_predicate> ::= </td>
	 *     <td> <img_column_reference> FAR <image_definition> </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> [BY <metric_name>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> [RANGE <val_range>] </td>
	 *   </tr>
	 *   <tr>
	 *     <td> </td>
	 *     <td> [STOP AFTER <k_nearest> [WITH <tie_list>]] </td>
	 *   </tr>
	 * </table>
	 */
	void far_predicate();

	//--------------------------------------------------------
	// insert statement rules methods
	//--------------------------------------------------------

	/**
	 * <b>Rule definition:</b><br>
	 * <insert_statement> ::= INSERT INTO <table_name> ['(' <insert_column_list> ')'] VALUES '(' <insert_value_list> ')'
	 */
	void insert_statement();

	/**
	 * <b>Rule definition:</b><br>
	 * <insert_column_list> ::= <insert_column> | <insert_column> ',' <insert_column_list>
	 */
	void insert_column_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <insert_column> ::= <column_reference>
	 */
	void insert_column();

	/**
	 * <b>Rule definition:</b><br>
	 * <insert_value_list> ::= <insert_value> | <insert_value> ',' <insert_value_list>
	 */
	void insert_value_list();

	/**
	 * <b>Rule definition:</b><br>
	 * <insert_value> ::= <value>
	 */
	void insert_value();

	//--------------------------------------------------------
	// other statements rules methods
	//--------------------------------------------------------

	/**
	 * <b>Method to describe circe data dictionary.</b><br>
	 * <b>Rule definition:</b><br>
	 * <describe_specification> ::= DESCRIBE METRIC <metric_name> | COMPLEX INDEX <image_index_name> | <table_name>
	 */
	void describe_specification();

	/**
	 * <b>Method to show circe data dictionary.</b><br>
	 * <b>Rule definition:</b><br>
	 * <show_specification> ::= SHOW EXTRACTORS | METRICS | COMPLEX INDEXES
	 */
	void show_specification();

	/**
	 * <b>Degub method to upload images.</b><br>
	 * The DML insert should be implemented to do this work!  :-)
	 */
	//void upload_images();

	void AddError(const string& error);
};

#endif
